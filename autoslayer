local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local AutoFarmActive = false
local currentTarget = nil
local connection = nil
local isExecuting = false
local executionQueue = {} -- Fila de slayers mortos pra executar

-- Movimento suave
local alignPos, alignOri, attachment = nil, nil, nil

-- CONFIGURAÇÕES (ajuste pro seu jogo)
local CONFIG = {
    HEIGHT = 6,              -- Altura acima do NPC
    BACK = 2,                -- Distância ATRÁS do NPC
    ANGLE = -70,             -- Inclinação pra baixo (menos inclinado pra acertar melhor)
    TP_DIST = 50,            -- Distância pra dar TP
    ATTACK_DIST = 10,        -- Distância pra atacar
    SAFE_RADIUS = 20,        -- Raio seguro pra executar
    MOVE_SPEED = 80,
    RESPONSIVENESS = 30,
    EXECUTE_WAIT = 2.5,      -- Tempo da animação de execução
}

-- ================== GUI ==================
local gui = Instance.new("ScreenGui")
gui.Name = "AutoFarmPro v27"
gui.ResetOnSpawn = false
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 160, 0, 100)
frame.Position = UDim2.new(0, 10, 0.5, -50)
frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
frame.BorderSizePixel = 0
frame.Parent = gui
Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 25)
title.BackgroundTransparency = 1
title.Text = "AutoFarm Pro"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 14
title.Font = Enum.Font.GothamBold
title.Parent = frame

local status = Instance.new("TextLabel")
status.Size = UDim2.new(1, 0, 0, 15)
status.Position = UDim2.new(0, 0, 0, 23)
status.BackgroundTransparency = 1
status.Text = "Desligado"
status.TextColor3 = Color3.fromRGB(150, 150, 150)
status.TextSize = 11
status.Font = Enum.Font.Gotham
status.Parent = frame

local btn = Instance.new("TextButton")
btn.Size = UDim2.new(0.85, 0, 0, 35)
btn.Position = UDim2.new(0.075, 0, 0, 55)
btn.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
btn.Text = "DESLIGADO"
btn.TextColor3 = Color3.fromRGB(255, 255, 255)
btn.TextSize = 14
btn.Font = Enum.Font.GothamBold
btn.Parent = frame
Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)

-- ================== UTILIDADES ==================
local function getHRP()
    local char = LocalPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart")
end

local function getRoot(model)
    return model:FindFirstChild("HumanoidRootPart") 
        or model:FindFirstChild("Torso") 
        or model:FindFirstChild("UpperTorso")
end

local function getHealth(model)
    local h = model:FindFirstChild("Health")
    if h then
        return h.Value
    end
    -- Tenta Humanoid também
    local hum = model:FindFirstChild("Humanoid")
    if hum then
        return hum.Health
    end
    return 0
end

local function isAlive(model)
    if not model or not model.Parent then return false end
    local hp = getHealth(model)
    return hp > 0
end

local function isDead(model)
    if not model or not model.Parent then return false end
    local hp = getHealth(model)
    return hp <= 0
end

local function dist(a, b)
    return (a - b).Magnitude
end

local function setStatus(txt)
    status.Text = txt
end

-- ================== BUSCA DE SLAYERS ==================
local function getAllSlayers()
    local alive, dead = {}, {}
    local hrp = getHRP()
    if not hrp then return alive, dead end
    
    for _, npc in ipairs(workspace:GetChildren()) do
        if npc.Name == "GenericSlayer" and npc:IsA("Model") then
            local root = getRoot(npc)
            if root then
                local d = dist(hrp.Position, root.Position)
                local data = {npc = npc, root = root, dist = d, pos = root.Position}
                
                if isAlive(npc) then
                    table.insert(alive, data)
                elseif isDead(npc) then
                    table.insert(dead, data)
                end
            end
        end
    end
    
    -- Ordena por distância (mais perto primeiro)
    table.sort(alive, function(a, b) return a.dist < b.dist end)
    table.sort(dead, function(a, b) return a.dist < b.dist end)
    
    return alive, dead
end

-- Verifica se tem slayer vivo perto de uma posição
local function hasAliveNear(position, radius)
    for _, npc in ipairs(workspace:GetChildren()) do
        if npc.Name == "GenericSlayer" and npc:IsA("Model") and isAlive(npc) then
            local root = getRoot(npc)
            if root and dist(root.Position, position) <= radius then
                return true
            end
        end
    end
    return false
end

-- Pega o melhor alvo vivo (prioriza quem tá perto)
local function getBestTarget()
    local alive, _ = getAllSlayers()
    if #alive == 0 then return nil end
    
    -- Retorna só se realmente tiver vivo
    for _, data in ipairs(alive) do
        if isAlive(data.npc) then
            return data
        end
    end
    return nil
end

-- Pega slayer morto que pode ser executado (sem vivos perto)
local function getExecutableDeadSlayer()
    local _, dead = getAllSlayers()
    for _, data in ipairs(dead) do
        if not hasAliveNear(data.pos, CONFIG.SAFE_RADIUS) then
            return data
        end
    end
    return nil
end

-- ================== REMOTES ==================
local remotes = ReplicatedStorage:WaitForChild("Remotes")
local syncRemote = remotes:WaitForChild("Sync")
local asyncRemote = remotes:WaitForChild("Async")

local function attack(npc)
    if npc:FindFirstChild("Block") then
        asyncRemote:FireServer("Katana", "Heavy")
    else
        asyncRemote:FireServer("Katana", "Server")
    end
end

local function execute()
    syncRemote:InvokeServer("Character", "Execute")
end

-- ================== MOVIMENTO ==================
local function setupMovement()
    local hrp = getHRP()
    if not hrp then return end
    
    -- Limpa antigos
    if attachment then attachment:Destroy() end
    if alignPos then alignPos:Destroy() end
    if alignOri then alignOri:Destroy() end
    
    attachment = Instance.new("Attachment")
    attachment.Parent = hrp
    
    alignPos = Instance.new("AlignPosition")
    alignPos.Mode = Enum.PositionAlignmentMode.OneAttachment
    alignPos.Attachment0 = attachment
    alignPos.MaxForce = 100000
    alignPos.MaxVelocity = CONFIG.MOVE_SPEED
    alignPos.Responsiveness = CONFIG.RESPONSIVENESS
    alignPos.Parent = hrp
    
    alignOri = Instance.new("AlignOrientation")
    alignOri.Mode = Enum.OrientationAlignmentMode.OneAttachment
    alignOri.Attachment0 = attachment
    alignOri.MaxTorque = 100000
    alignOri.Responsiveness = CONFIG.RESPONSIVENESS
    alignOri.Parent = hrp
end

local function clearMovement()
    if attachment then attachment:Destroy() attachment = nil end
    if alignPos then alignPos:Destroy() alignPos = nil end
    if alignOri then alignOri:Destroy() alignOri = nil end
end

local function getFarmPosition(npcRoot)
    local pos = npcRoot.Position
    local look = npcRoot.CFrame.LookVector
    
    -- Posição: ACIMA e ATRÁS do NPC
    local targetPos = pos + Vector3.new(0, CONFIG.HEIGHT, 0) - (look * CONFIG.BACK)
    
    -- Olha pro NPC (pra baixo e pra frente)
    local lookAtPos = pos
    local cf = CFrame.new(targetPos, lookAtPos)
    
    -- Inclina um pouco pra baixo
    return cf * CFrame.Angles(math.rad(CONFIG.ANGLE), 0, 0)
end

local function moveTo(cf)
    if alignPos and alignOri then
        alignPos.Position = cf.Position
        alignOri.CFrame = cf
    end
end

local function teleportTo(cf)
    local hrp = getHRP()
    if hrp then
        hrp.CFrame = cf
    end
end

-- ================== EXECUÇÃO ==================
local function doExecution(data)
    if isExecuting then return false end
    isExecuting = true
    
    local hrp = getHRP()
    if not hrp then 
        isExecuting = false 
        return false 
    end
    
    print("Iniciando execução...")
    setStatus("Executando...")
    
    -- Desativa movimento suave
    if alignPos then alignPos.Enabled = false end
    if alignOri then alignOri.Enabled = false end
    
    -- TP pra perto do slayer morto (2 studs acima do chão)
    local executePos = data.pos + Vector3.new(0, 2, 0)
    hrp.CFrame = CFrame.new(executePos, data.pos)
    
    print("Teleportou pra posição de execução")
    task.wait(0.3)
    
    -- Verifica se ainda tá seguro (sem vivo perto)
    if hasAliveNear(data.pos, CONFIG.SAFE_RADIUS) then
        print("Execução cancelada - tem vivo perto!")
        setStatus("Interrompido!")
        if alignPos then alignPos.Enabled = true end
        if alignOri then alignOri.Enabled = true end
        isExecuting = false
        return false
    end
    
    -- Executa
    print("Chamando remote de execução...")
    execute()
    print("Executado com sucesso!")
    
    task.wait(CONFIG.EXECUTE_WAIT)
    
    -- Reativa movimento
    if alignPos then alignPos.Enabled = true end
    if alignOri then alignOri.Enabled = true end
    isExecuting = false
    
    return true
end

-- ================== LOOP PRINCIPAL ==================
local function mainLoop()
    if not AutoFarmActive or isExecuting then return end
    
    local hrp = getHRP()
    if not hrp then return end
    
    -- Garante que movimento tá configurado
    if not alignPos or not alignPos.Parent then
        setupMovement()
    end
    
    local myPos = hrp.Position
    
    -- Se tem alvo atual, verifica se morreu
    if currentTarget then
        if isDead(currentTarget) then
            print("Alvo morreu! Adicionando na fila...")
            local root = getRoot(currentTarget)
            if root then
                local inQueue = false
                for _, q in ipairs(executionQueue) do
                    if q.npc == currentTarget then inQueue = true break end
                end
                if not inQueue then
                    table.insert(executionQueue, {npc = currentTarget, pos = root.Position})
                end
            end
            currentTarget = nil
            return
        end
    end
    
    -- PRIORIDADE 1: Matar slayers vivos
    local target = getBestTarget()
    
    if target and isAlive(target.npc) then
        currentTarget = target.npc
        local targetDist = target.dist
        local targetRoot = target.root
        
        -- TP se muito longe
        if targetDist > CONFIG.TP_DIST then
            setStatus("Teleportando...")
            teleportTo(getFarmPosition(targetRoot))
            task.wait(0.1)
            return
        end
        
        -- Move suave
        moveTo(getFarmPosition(targetRoot))
        
        -- Ataca só se perto E vivo
        if targetDist <= CONFIG.ATTACK_DIST then
            setStatus("Atacando")
            attack(currentTarget)
        else
            setStatus("Aproximando...")
        end
        
        return
    end
    
    -- Se chegou aqui, não tem vivo pra atacar
    currentTarget = nil
    
    -- PRIORIDADE 2: Executar mortos da fila
    if #executionQueue > 0 then
        local data = executionQueue[1]
        if data.npc and data.npc.Parent and isDead(data.npc) then
            if not hasAliveNear(data.pos, CONFIG.SAFE_RADIUS) then
                table.remove(executionQueue, 1)
                doExecution(data)
                return
            else
                setStatus("Área não segura...")
                return
            end
        else
            table.remove(executionQueue, 1)
            return
        end
    end
    
    -- PRIORIDADE 3: Procura mortos no mapa que podem ser executados
    local deadTarget = getExecutableDeadSlayer()
    if deadTarget then
        doExecution(deadTarget)
        return
    end
    
    -- Nada pra fazer
    setStatus("Procurando...")
end

-- ================== CONTROLE ==================
local function start()
    setupMovement()
    executionQueue = {}
    
    -- Ao ligar: executa mortos disponíveis primeiro
    local deadTarget = getExecutableDeadSlayer()
    if deadTarget then
        doExecution(deadTarget)
    end
    
    connection = RunService.Heartbeat:Connect(mainLoop)
end

local function stop()
    if connection then
        connection:Disconnect()
        connection = nil
    end
    clearMovement()
    currentTarget = nil
    executionQueue = {}
    isExecuting = false
    setStatus("Desligado")
end

-- ================== TOGGLE ==================
btn.MouseButton1Click:Connect(function()
    AutoFarmActive = not AutoFarmActive
    
    if AutoFarmActive then
        btn.BackgroundColor3 = Color3.fromRGB(40, 180, 40)
        btn.Text = "LIGADO"
        start()
    else
        btn.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
        btn.Text = "DESLIGADO"
        stop()
    end
end)

-- Respawn
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if AutoFarmActive then
        setupMovement()
    end
end)

print("AutoFarm Pro v6 carregado!")
